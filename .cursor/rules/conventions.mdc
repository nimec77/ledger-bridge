---
alwaysApply: false
---
## Error Handling (Critical)

### Mandatory Rules
- ❌ **NEVER** use `.unwrap()` or `.expect()` in library code
- ❌ **NO PANICS** in library code
- ✅ Always return `Result<T, ParseError>`
- ✅ Use explicit error propagation with `?` operator
- ✅ Implement `std::error::Error` and `std::fmt::Display` for all error types
- ✅ CLI handles display and exit codes; library only returns errors

### Error Type
- Use single unified `ParseError` enum across entire library
- Provide descriptive error messages (context-specific)
- Implement `From<std::io::Error>` for automatic conversion

---

## Format Implementation

### Required Methods
Each format struct must implement:
1. **`from_read()`** - Parse from any `Read` source
2. **`write_to()`** - Write to any `Write` destination
3. **`From` trait** - Convert from/to other format structs

### Implementation Pattern
```rust
impl Mt940 {
    /// Parse from any Read source (file, stdin, buffer)
    pub fn from_read<R: std::io::Read>(reader: &mut R) -> Result<Self, ParseError> {
        // Read data using reader.read_to_string() or appropriate method
        // Parse format-specific structure
        // Return Self
    }
    
    /// Write to any Write destination (file, stdout, buffer)
    pub fn write_to<W: std::io::Write>(&self, writer: &mut W) -> Result<(), ParseError> {
        // Format self as output string/bytes
        // Write using writer.write_all()
        // Return Ok(()) or error
    }
}

/// Type conversions between formats
impl From<Camt053> for Mt940 {
    fn from(camt: Camt053) -> Self {
        // Field-by-field conversion
    }
}
```

---

## Code Style

### Explicitness
- **Explicit over implicit** - Clear code over clever tricks
- Explicit type conversions using trait implementations
- No magic numbers - use named constants or document inline

### Simplicity
- Start with simplest implementation that works
- Avoid premature optimization
- Refactor only when needed
- Keep parsing logic straightforward (manual string processing is fine)

### Data Structures
- All public types must derive:
  - `Debug`, `Clone`, `PartialEq` (testing)
  - `Serialize`, `Deserialize` (serde integration)
- Format structs have identical field structure (enables simple `From` implementations)
- Shared types (Transaction, BalanceType) used across all formats

---

## Documentation

### Requirements
- ✅ All **public** items need doc comments (`///`)
- ✅ Document **why** decisions were made, not just what
- ✅ Include examples in docs where helpful
- ✅ Document method contracts (what Read/Write expects)

### Style
```rust
/// CSV bank statement structure.
///
/// Parses from and writes to CSV format using the `csv` crate.
/// Fields are identical to Mt940/Camt053 for seamless conversions.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CsvStatement {
    pub account_number: String,
    // ... fields
}

impl CsvStatement {
    /// Parse CSV from any Read source.
    ///
    /// # Errors
    /// Returns `ParseError::CsvError` if the CSV structure is invalid.
    ///
    /// # Example
    /// ```
    /// let mut reader = csv_data.as_bytes();
    /// let statement = CsvStatement::from_read(&mut reader)?;
    /// ```
    pub fn from_read<R: std::io::Read>(reader: &mut R) -> Result<Self, ParseError> {
        // Implementation
    }
}
```

---

## Testing

### Coverage Requirements
- Unit tests for each format's `from_read()` (happy path + error cases)
- Unit tests for each format's `write_to()` (happy path + error cases)
- Integration tests for `From` trait conversions between formats
- Test error cases, not just success paths

### Test Organization
- Unit tests in `#[cfg(test)]` modules within implementation files
- Integration tests in `tests/` directory
- Use inline test data (string literals), no external files
- Keep tests simple and readable

### Test Data
```rust
#[test]
fn test_parse_csv() {
    let input = "Account,Currency,...\n...";
    let mut reader = input.as_bytes();
    let result = CsvStatement::from_read(&mut reader);
    assert!(result.is_ok());
}

#[test]
fn test_write_csv() {
    let statement = CsvStatement { /* ... */ };
    let mut output = Vec::new();
    let result = statement.write_to(&mut output);
    assert!(result.is_ok());
    assert!(!output.is_empty());
}

#[test]
fn test_conversion() {
    let mt940 = Mt940 { /* ... */ };
    let camt053: Camt053 = mt940.into();
    assert_eq!(camt053.account_number, "...");
}
```

---

## Dependencies

### Required Libraries
- **`serde`** (with derive feature) - Data structure serialization
- **`csv`** (v1.3) - CSV parsing with Read/Write support (Trust Score: 9.1)
- **`quick-xml`** (v0.31) - XML parsing for CAMT.053 (Trust Score: 9.2)
- **CLI only**: `clap` (with derive feature) - Argument parsing

### Parsing Approach
- **CSV**: Use `csv` crate with `Reader::from_reader()` and `Writer::from_writer()`
- **MT940**: Manual parsing (educational value, demonstrates text processing)
- **CAMT.053**: Use `quick-xml` with event-based parsing or Serde deserialization

### Dependency Rules
- Standard library `Read`/`Write` traits are primary abstractions
- External libraries must support Read/Write traits
- Manual parsing acceptable when educational

---

## Anti-Patterns (Must Avoid)

### Forbidden Practices
- ❌ `.unwrap()` or `.expect()` in library code
- ❌ Overly generic code that obscures intent
- ❌ Silent error swallowing (always propagate or handle explicitly)
- ❌ Undocumented format assumptions
- ❌ Complex abstractions when simple code suffices

### Code Smells
- Magic numbers without explanation
- Deeply nested match statements (flatten with early returns)
- Duplicated parsing logic (extract to helper functions)
- Missing error context (wrap errors with descriptive messages)

---

## I/O Patterns

### Input Handling (Read Trait)
- All `from_read()` methods accept `&mut R` where `R: std::io::Read`
- Works with: files, stdin, in-memory buffers, network streams
- Use `read_to_string()` for text formats, buffered reading for large files
- Library uses Read abstraction; caller provides the actual source

### Output Handling (Write Trait)
- All `write_to()` methods accept `&mut W` where `W: std::io::Write`
- Works with: files, stdout, in-memory buffers (Vec<u8>), network streams
- Use `write_all()` for complete output, `write_fmt!()` for formatted output
- Library uses Write abstraction; caller provides the actual destination

### Benefits
- Single implementation works with any Read/Write source
- No code duplication for files vs stdin/stdout
- Demonstrates standard library trait power

---

## Naming Conventions

### Types
- Format structs: `Mt940`, `Camt053`, `CsvStatement`
- Shared data: `Transaction`, `BalanceType`, `TransactionType`
- Errors: `ParseError` (single unified enum)

### Methods
- Parsing: `fn from_read<R: Read>(reader: &mut R) -> Result<Self, ParseError>`
- Formatting: `fn write_to<W: Write>(&self, writer: &mut W) -> Result<(), ParseError>`

### Variables
- Use descriptive names (no single-letter except loop indices)
- `reader` for Read sources
- `writer` for Write destinations
- Format-specific variable names: `mt940`, `camt053`, `csv_statement`

---

## Version Control

### Commits
- Commit working increments (parsable code)
- Write clear commit messages
- Don't commit broken code (must compile)

### Git Workflow
- Keep commits focused (one logical change)
- Test before committing

---

## CLI Guidelines

### Argument Parsing
- Use `clap` with derive macros
- Support both file and stdin/stdout
- Case-insensitive format names (`csv`, `CSV`, `Csv` all valid)

### Error Display
- Print parse/format errors to stderr
- Exit with code 1 on error, 0 on success
- Use `unwrap_or_else()` with custom error messages for CLI (library stays panic-free)

### Usage Pattern
```bash
ledger-bridge --in-format csv --out-format mt940 --input data.csv --output result.mt940
cat input.csv | ledger-bridge --in-format csv --out-format camt053 > output.xml
```

---

## Learning Focus

### Core Objectives
1. **Standard library I/O traits** - Master `Read` and `Write` for flexible I/O
2. **Type conversions with From trait** - Implement `From` for format conversions
3. **Static polymorphism** - Generic functions without runtime overhead
4. **Error handling** - Explicit `Result` types, custom error implementations
5. **Practical parsing** - Real-world formats with appropriate libraries

### Write Verbose Code When
- It demonstrates Read/Write trait benefits
- Makes error handling explicit
- Clarifies type conversions between formats
- Documents parsing strategy decisions

---

## Summary

**Key Principle**: Keep It Simple and Stupid (KISS)

When in doubt:
1. Choose simpler implementation
2. Be explicit about errors
3. Document the "why"
4. Test both success and failure
5. Reference [@vision.md](vision.md) for detailed specifications

---

*This document contains only the essential rules that impact code quality. For complete technical specifications, architecture details, and format parsing strategies, see [vision.md](vision.md).*
